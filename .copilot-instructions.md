# Wiley Widget - GitHub Copilot Instructions

## Project Overview
Wiley Widget is a .NET 8.0 WPF application with comprehensive CI/CD pipeline using GitHub Actions, Trunk for code quality, and Azure deployment capabilities.

## Core Technologies
- **Framework**: .NET 8.0 WPF (Windows desktop application)
- **Database**: Azure SQL with Entity Framework Core 9.0.8
- **Testing**: xUnit 2.9.2 with 100% coverage requirement
- **CI/CD**: GitHub Actions with Trunk integration
- **Code Quality**: Trunk CLI with security scanning and formatting
- **Deployment**: Azure Web Apps with automated pipelines

## CI/CD Workflow Methods & Best Practices

### Primary CI/CD Workflows

#### 1. Comprehensive CI/CD Pipeline (`comprehensive-cicd.yml`)
**Purpose**: Enterprise-grade CI/CD with full quality assurance
**Triggers**: Push to main, PR to main, manual dispatch
**Key Features**:
- Parallel security and quality scanning
- Automated testing with coverage
- Trunk flaky test detection
- Artifact generation and upload

```yaml
# Usage: Automatic on push/PR, or manual trigger
name: CI/CD with Trunk Quality Assurance
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      run_full_security_scan:
        description: 'Run full security scan (slower)'
        required: false
        default: false
```

#### 2. Merge Queue Compatible Pipeline (`merge-queue-cicd.yml`)
**Purpose**: Optimized for merge queue automation
**Triggers**: Push, PR, merge_group (for merge queues)
**Key Features**:
- Merge queue support with `merge_group` trigger
- Draft PR testing capabilities
- Enhanced status reporting
- Branch protection rule compliance

#### 3. Release Pipeline (`release-new.yml`)
**Purpose**: Production releases with enhanced validation
**Triggers**: Push to main, manual release
**Key Features**:
- Release package generation
- Enhanced security scanning
- Production artifact creation
- Release notes automation

#### 4. CI Pipeline (`ci-new.yml`)
**Purpose**: Fast feedback for development
**Triggers**: Push to any branch
**Key Features**:
- Quick quality validation
- Basic security checks
- Development branch support

### Essential CI/CD Commands

#### PowerShell Commands (Primary Shell)
```powershell
# Validate CI/CD setup
.\scripts\validate-merge-queue.ps1 -Verbose

# Trunk maintenance and diagnostics
.\scripts\trunk-maintenance.ps1 -Diagnose -Fix

# Enhanced Trunk setup
.\scripts\enhanced-trunk-setup.ps1 -EnableAllActions -SetupEnhancedHooks

# Generate CI/CD manifests
.\scripts\ci-generate-manifest.ps1 -Environment "Production"
```

#### Trunk CLI Commands
```bash
# Full quality check
trunk check --all --ci

# Security-focused check
trunk check --scope security --ci

# Auto-format code
trunk fmt --ci

# Upload test results to Trunk
trunk flakytests upload --junit-paths "TestResults/*/test-results.xml" --org-url-slug $TRUNK_ORG_URL_SLUG --token $TRUNK_API_TOKEN
```

### GitHub Secrets Configuration

#### Required Secrets for CI/CD:
```bash
# Trunk Integration
TRUNK_ORG_URL_SLUG: Your Trunk organization slug
TRUNK_API_TOKEN: Your Trunk API token
TRUNK_TOKEN: Legacy token (if needed)

# Azure Deployment (if applicable)
AZURE_CREDENTIALS: Azure service principal credentials
AZURE_SQL_CONNECTION_STRING: Database connection string
```

### Branch Protection Rules

#### Recommended Configuration:
1. **Require pull request** before merging
2. **Require approvals**: 1 (minimum)
3. **Dismiss stale reviews** when new commits
4. **Require review from Code Owners**
5. **Restrict pushes** that create matching branches

#### Required Status Checks:
- `test` - Unit test execution
- `build` - .NET compilation
- `security-scan` - Trunk security analysis
- `lint` - Code quality checks
- `coverage` - Test coverage validation

### Workflow Job Structure

#### Quality Assurance Job:
```yaml
quality:
  name: Code Quality
  runs-on: windows-latest
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Trunk Security Scan
      uses: trunk-io/trunk-action@v1
      with:
        arguments: --ci --upload --series=${{ github.ref_name }} --scope=security
      env:
        TRUNK_TOKEN: ${{ secrets.TRUNK_API_TOKEN }}

    - name: Trunk Code Quality Scan
      uses: trunk-io/trunk-action@v1
      with:
        arguments: --ci --upload --series=${{ github.ref_name }} --filter=psscriptanalyzer,prettier
      env:
        TRUNK_TOKEN: ${{ secrets.TRUNK_API_TOKEN }}
```

#### Build & Test Job:
```yaml
build-test:
  name: Build & Test
  runs-on: windows-latest
  steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Build
      run: dotnet build --no-restore --configuration Release

    - name: Run Tests
      run: |
        dotnet test --no-build --configuration Release --verbosity normal --collect:"XPlat Code Coverage" --logger "trx;LogFileName=test-results.trx" --logger "junit;LogFileName=test-results.xml"

    - name: Upload Test Results to Trunk
      if: always()
      uses: trunk-io/analytics-uploader@v1
      with:
        junit-paths: "TestResults/*/test-results.xml"
        org-slug: ${{ secrets.TRUNK_ORG_URL_SLUG }}
        token: ${{ secrets.TRUNK_API_TOKEN }}
```

### Merge Queue Integration

#### Setting Up Merge Queues:
1. **Configure Branch Protection** (see above)
2. **Enable Merge Queue in Trunk** (if using Trunk merge queues)
3. **Use Compatible Workflows** with `merge_group` triggers
4. **Test with Draft PRs** for validation

#### Manual Merge Process (Alternative):
```powershell
# For repositories without merge queue automation
# 1. Create feature branch
git checkout -b feature/new-feature

# 2. Make changes and commit
git add . && git commit -m "feat: new feature"

# 3. Push and create PR
git push -u origin feature/new-feature

# 4. Wait for CI/CD to pass
# 5. Merge PR through GitHub interface
```

### Troubleshooting CI/CD Issues

#### Common Problems & Solutions:

**1. Token Authentication Issues:**
```powershell
# Check secrets configuration
gh secret list

# Validate token format
.\scripts\validate-merge-queue.ps1 -Verbose
```

**2. Workflow Failures:**
```powershell
# Check workflow logs in GitHub Actions
# Look for specific error messages
# Verify .NET version compatibility
# Check NuGet package availability
```

**3. Trunk Integration Issues:**
```powershell
# Diagnose Trunk problems
.\scripts\trunk-maintenance.ps1 -Diagnose

# Fix common issues
.\scripts\trunk-maintenance.ps1 -Fix

# Reset Trunk configuration
.\scripts\trunk-maintenance.ps1 -Reset
```

**4. Test Failures:**
```powershell
# Run tests locally first
dotnet test --verbosity detailed

# Check test data setup
# Verify mocking configuration
# Review test isolation
```

**5. Build Failures:**
```powershell
# Check .NET version
dotnet --version

# Restore dependencies
dotnet restore

# Clean and rebuild
dotnet clean && dotnet build
```

### Performance Optimization

#### Build Optimization:
- Use incremental builds with `--no-restore`
- Cache NuGet packages between runs
- Parallel test execution
- Minimize artifact uploads

#### CI/CD Optimization:
- Use matrix builds for multiple configurations
- Conditional job execution based on file changes
- Artifact caching between workflow runs
- Strategic use of `continue-on-error`

### Quality Gates & Metrics

#### Code Coverage:
- **Minimum**: 80%
- **Target**: 100%
- **Tools**: Coverlet, ReportGenerator
- **Reporting**: HTML and Cobertura formats

#### Security Requirements:
- **Zero critical vulnerabilities**
- **Regular dependency updates**
- **Automated security scanning**
- **Secret detection and prevention**

#### Performance Benchmarks:
- **Build Time**: < 10 minutes
- **Test Execution**: < 5 minutes
- **Security Scan**: < 3 minutes
- **Total Pipeline**: < 15 minutes

### Deployment Integration

#### Azure Web App Deployment:
```yaml
- name: Deploy to Azure
  uses: azure/webapps-deploy@v3
  with:
    app-name: wiley-widget
    slot-name: production
    publish-profile: ${{ secrets.AZURE_PUBLISH_PROFILE }}
```

#### Database Migrations:
```yaml
- name: Run Database Migrations
  run: |
    dotnet ef database update --project WileyWidget.csproj
  env:
    ConnectionStrings__DefaultConnection: ${{ secrets.AZURE_SQL_CONNECTION_STRING }}
```

### Best Practices Summary

#### 1. Always Use Feature Branches
```bash
# Never commit directly to main
git checkout -b feature/description
git commit -m "feat: description"
git push -u origin feature/description
```

#### 2. Run Quality Checks Locally
```bash
# Before pushing
trunk check --ci
trunk check --scope security --ci
```

#### 3. Write Meaningful Commit Messages
```bash
# Good examples
git commit -m "feat: add user authentication with JWT tokens"
git commit -m "fix: resolve null reference in data processing"
git commit -m "docs: update CI/CD workflow documentation"
```

#### 4. Handle Errors Appropriately
```csharp
// C# error handling pattern
try
{
    await _service.ProcessAsync(data);
}
catch (ValidationException ex)
{
    _logger.LogWarning(ex, "Validation failed: {Message}", ex.Message);
    throw;
}
catch (Exception ex)
{
    _logger.LogError(ex, "Unexpected error in data processing");
    throw new ApplicationException("Data processing failed", ex);
}
```

#### 5. Test Everything
```bash
# Run full test suite
dotnet test --collect:"XPlat Code Coverage"

# Run specific test category
dotnet test --filter Category=Unit

# Run with detailed output
dotnet test --verbosity detailed
```

### File Organization for CI/CD

#### Scripts Directory Structure:
```
scripts/
├── trunk-maintenance.ps1          # Trunk diagnostics and fixes
├── validate-merge-queue.ps1       # CI/CD validation
├── enhanced-trunk-setup.ps1       # Advanced Trunk configuration
├── ci-generate-manifest.ps1       # CI/CD manifest generation
├── setup-flaky-tests.ps1          # Test flakiness detection setup
└── [other automation scripts]
```

#### GitHub Workflows:
```
.github/
├── workflows/
│   ├── comprehensive-cicd.yml     # Main CI/CD pipeline
│   ├── merge-queue-cicd.yml       # Merge queue compatible
│   ├── release-new.yml            # Release pipeline
│   └── ci-new.yml                 # Fast CI pipeline
```

#### Configuration Files:
- `.trunk/trunk.yaml` - Trunk linter and tool configuration
- `.trunk/configs/` - Custom linter configurations
- `.github/dependabot.yml` - Dependency updates
- `Directory.Build.props` - MSBuild configuration

### Support and Resources

#### Documentation:
- [Trunk CI/CD Documentation](https://docs.trunk.io/cli)
- [GitHub Actions Documentation](https://docs.github.com/actions)
- [Azure Deployment Documentation](https://docs.microsoft.com/azure)
- [.NET CI/CD Best Practices](https://docs.microsoft.com/dotnet/devops)

#### Tools & Services:
- **Trunk**: Code quality, security, and formatting
- **GitHub Actions**: CI/CD automation
- **Azure DevOps**: Project management and deployment
- **Coverlet**: .NET code coverage
- **ReportGenerator**: Coverage report generation

### Communication Standards

#### Issue Reporting:
- Use descriptive issue titles
- Include reproduction steps
- Provide environment details
- Attach relevant log files
- Tag appropriate team members

#### Pull Request Standards:
- Reference related issues
- Include testing instructions
- Update documentation if needed
- Request appropriate reviewers
- Ensure CI/CD passes before review

---

*This document serves as the comprehensive guide for Wiley Widget CI/CD methods and development best practices. Regular updates will reflect new tools, processes, and lessons learned.*
- **Pre-push**: Security validation and comprehensive testing
- **CI Pipeline**: Parallel security scanning and quality validation
- **Artifact Generation**: Automated manifest and diagnostics upload

## Development Workflow

### 1. Local Development
```bash
# Start with fresh environment
git pull && trunk check --ci

# Make changes
# ... edit files ...

# Pre-commit validation
git add . && git commit -m "feat: description"

# Pre-push validation
git push
```

### 2. Quality Gates
- **Security**: Zero critical/high severity issues
- **Code Coverage**: Minimum 80% (target 100%)
- **Formatting**: All files must pass linter rules
- **Build**: Clean compilation required
- **Tests**: All tests must pass

### 3. Troubleshooting
```powershell
# If Trunk appears offline
.\scripts\trunk-maintenance.ps1 -Diagnose -Fix

# Clear cache and restart
trunk cache clean && trunk daemon restart

# Check tool installations
Get-ChildItem "$env:LOCALAPPDATA\trunk\tools" -Directory
```

## Code Quality Standards

### C# Code Style
- Use `var` for implicit typing where clear
- Follow .NET naming conventions
- Use async/await for I/O operations
- Implement proper error handling
- Use dependency injection
- Follow SOLID principles

### PowerShell Scripts
- Use full cmdlet names (not aliases)
- Include comment-based help
- Use parameter validation
- Handle errors with try/catch
- Follow PowerShell naming conventions

### Security Requirements
- No hardcoded secrets or credentials
- Use environment variables for configuration
- Implement proper input validation
- Follow OWASP guidelines
- Regular dependency updates

## File Organization

### Scripts Directory
```
scripts/
├── trunk-maintenance.ps1          # Trunk diagnostics and fixes
├── enhanced-trunk-setup.ps1       # Advanced Trunk configuration
├── ci-generate-manifest.ps1       # CI/CD manifest generation
├── Generate-FetchabilityManifest.ps1  # Core manifest logic
├── Generate-FetchabilityManifest-Wrapper.ps1  # Wrapper script
└── [other automation scripts]
```

### Configuration Files
- `.trunk/trunk.yaml` - Trunk linter and tool configuration
- `.trunk/configs/` - Custom linter configurations
- `.github/workflows/` - CI/CD pipeline definitions
- `appsettings.json` - Application configuration

## Git Workflow

### Branch Strategy
- `main` - Production branch with full quality gates
- `feature/*` - Feature branches with relaxed validation
- `hotfix/*` - Emergency fixes with expedited review

### Commit Standards
```bash
# Feature commits
git commit -m "feat: add user authentication"

# Bug fixes
git commit -m "fix: resolve null reference exception"

# Documentation
git commit -m "docs: update API documentation"

# Refactoring
git commit -m "refactor: simplify data access layer"
```

### Pre-commit Hooks
- Automatic code formatting
- Basic quality validation
- Manifest generation
- File staging

### Pre-push Hooks
- Security scanning
- Comprehensive testing
- Coverage validation
- Build verification

## CI/CD Pipeline

### Stages
1. **Checkout** - Full history for security scanning
2. **Setup** - .NET and dependency installation
3. **Quality** - Trunk security and code quality checks
4. **Build** - .NET compilation with detailed logging
5. **Test** - Unit testing with coverage collection
6. **Analysis** - Coverage threshold validation
7. **Artifacts** - Build artifacts and diagnostics upload

### Quality Metrics
- **Build Success Rate**: ≥95%
- **Test Pass Rate**: 100%
- **Coverage**: ≥80%
- **Security Findings**: Zero critical issues
- **Performance**: <10 minute build time

## Deployment

### Azure Integration
- **Database**: Azure SQL with automated migrations
- **Web App**: Azure App Service with staging slots
- **Security**: Azure Key Vault for secrets
- **Monitoring**: Application Insights integration

### Environment Configuration
- **Development**: Local development with in-memory database
- **Staging**: Azure staging environment with test data
- **Production**: Azure production with live data

## Best Practices

### 1. Always Run Quality Checks
```bash
# Before committing
trunk check --ci

# Before pushing
trunk check --scope security --ci
```

### 2. Use Descriptive Commit Messages
- Start with type: feat, fix, docs, refactor, test
- Use imperative mood: "add", not "added"
- Keep under 50 characters
- Add body for complex changes

### 3. Handle Errors Properly
```csharp
// C# error handling
try
{
    await _service.ProcessDataAsync(data);
}
catch (ValidationException ex)
{
    _logger.LogWarning(ex, "Validation failed for data {@Data}", data);
    throw;
}
```

### 4. Write Testable Code
- Use dependency injection
- Avoid static dependencies
- Create focused, single-responsibility methods
- Use interfaces for mocking

### 5. Security First
- Never commit secrets
- Use environment variables
- Validate all inputs
- Keep dependencies updated
- Regular security scans

## Troubleshooting Guide

### Trunk Issues
```powershell
# Diagnose problems
.\scripts\trunk-maintenance.ps1 -Diagnose

# Fix common issues
.\scripts\trunk-maintenance.ps1 -Fix

# Reset if needed
.\scripts\trunk-maintenance.ps1 -Reset
```

### Build Failures
1. Check .NET version compatibility
2. Verify NuGet package versions
3. Review build logs for specific errors
4. Check disk space and permissions

### Test Failures
1. Run tests locally first
2. Check test data and setup
3. Review test isolation
4. Verify mocking setup

### Deployment Issues
1. Check Azure resource status
2. Verify connection strings
3. Review deployment logs
4. Check environment variables

## Performance Optimization

### Build Performance
- Use incremental builds
- Cache NuGet packages
- Parallel test execution
- Minimize artifact size

### Runtime Performance
- Use async/await properly
- Implement caching where appropriate
- Optimize database queries
- Monitor memory usage

### CI/CD Performance
- Use matrix builds for parallel execution
- Cache dependencies between runs
- Minimize artifact uploads
- Use conditional execution

## Support and Resources

### Documentation
- [Trunk CLI Documentation](https://docs.trunk.io)
- [.NET Documentation](https://docs.microsoft.com/dotnet)
- [Azure Documentation](https://docs.microsoft.com/azure)

### Tools
- **Trunk**: Code quality and security
- **GitHub Actions**: CI/CD automation
- **Azure DevOps**: Project management
- **Visual Studio**: Primary IDE

### Communication
- Use descriptive issue titles
- Include reproduction steps
- Provide environment details
- Tag appropriate team members

---

*This document serves as a comprehensive guide for Wiley Widget development. Regular updates will reflect new best practices and lessons learned.*
