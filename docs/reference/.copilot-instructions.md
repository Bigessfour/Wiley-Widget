# Wiley Widget Development Guidelines - Python Tooling

## ‚ö†Ô∏è FILESYSTEM MCP MANDATORY ENFORCEMENT

**CRITICAL: ALL FILE OPERATIONS MUST USE MCP FILESYSTEM TOOLS**

**BEFORE ANY FILE OPERATION:**

1. **Activate filesystem tools:**

   ```javascript
   activate_file_reading_tools(); // For reads
   activate_directory_and_file_creation_tools(); // For writes/edits
   ```

2. **Self-check:**
   - Am I using `mcp_filesystem_*` function?
   - If NO ‚Üí STOP and switch to MCP tool
   - If YES ‚Üí Proceed

### **PROHIBITED Tools (‚ùå NEVER USE FOR FILES):**

- `read_file` ‚Üí Use `mcp_filesystem_read_text_file`
- `grep_search` ‚Üí Use `mcp_filesystem_search_files`
- `file_search` ‚Üí Use `mcp_filesystem_search_files`
- Terminal commands for file I/O ‚Üí Use MCP tools

### **Enforcement Level: STRICT - Zero Tolerance**

**Why mandatory:**

- ‚úÖ Git-style diffs for all changes
- ‚úÖ Atomic operations with rollback
- ‚úÖ Audit trail for all file modifications
- ‚úÖ Consistent tool usage across conversations

**See `.vscode/copilot-mcp-rules.md` for complete enforcement rules and violation examples.**

---

## üîß MCP Tools Integration

### **Automatic MCP Tool Usage**

The following MCP (Model Context Protocol) tools are automatically available and should be used proactively in the development workflow:

#### **C# MCP Server (`mcp_csharp-mcp_eval_c_sharp`)**

- **When to use**: Automatically evaluate C# code snippets, test scripts, or small programs
- **Integration**: Use for validating C# syntax, running quick tests, or prototyping code before implementation
- **Workflow placement**: During code review, testing phases, or when analyzing C# files

#### **Filesystem MCP (`mcp_filesystem_*`)**

- **When to use**: For file system operations like reading, writing, searching, or analyzing files
- **Integration**: Use for bulk file operations, directory analysis, or when working with large codebases
- **Workflow placement**: During project analysis, file management, or when exploring workspace structure

#### **Sequential Thinking MCP (`mcp_sequential-th_sequentialthinking`)**

- **When to use**: For complex problem-solving requiring step-by-step analysis and iterative refinement
- **Integration**: Use for architectural decisions, debugging complex issues, or multi-step implementation planning
- **Workflow placement**: During design phases, troubleshooting, or when breaking down complex tasks

### üìã **MCP Tool Usage Guidelines**

- **Proactive Usage**: Use these tools automatically when their capabilities would benefit the task
- **No Explicit Request Required**: Integrate tool usage naturally into responses without waiting for user prompts
- **Fallback Strategy**: If MCP tools fail or are unavailable, gracefully fall back to standard tools
- **Documentation**: Log MCP tool usage in commit messages when tools contribute to solutions

---

## üêç Python-First Development Environment

This project uses a comprehensive Python-based tooling ecosystem that has replaced legacy PowerShell scripts for better cross-platform support, maintainability, and testing capabilities.

## üöÄ Core Development Workflow

### Development Startup

**Use**: `python scripts/dev-start.py` or VS Code task "dev-start"

- Cleans orphaned .NET processes
- Performs build hygiene (`dotnet clean`)
- Applies Azure performance optimizations
- Launches `dotnet watch` with monitoring

### Environment Management

**Use**: `python scripts/load-env.py`

- Loads configuration from `.env` file
- Resolves secret references from `.env` and local secret stores
- Validates database connectivity (Microsoft SQL Server Express)
- Masks sensitive data in logs

**Commands**:

```bash
python scripts/load-env.py              # Load environment
python scripts/load-env.py --status     # Check status
python scripts/load-env.py --test-connections  # Test DB connections
```

### Database Setup (SQL Server Express)

- Wiley-Widget uses Microsoft SQL Server Express for local development and CI when appropriate.
- Ensure a local SQL Server Express instance is running and accessible.
- Configure the application's connection string in `.env` or `appsettings.json` per project conventions.
- For EF Core migrations or database updates use the provided tasks or run EF Core commands. Example:

```powershell
dotnet ef database update --project "WileyWidget.Data/WileyWidget.Data.csproj" --startup-project "WileyWidget.csproj"
```

### Process Cleanup

**Use**: `python scripts/cleanup-dotnet.py`

- Safely removes orphaned .NET processes
- Cleans build artifacts
- Interactive confirmation mode

**Commands**:

```bash
python scripts/cleanup-dotnet.py        # Interactive cleanup
python scripts/cleanup-dotnet.py --force # Force cleanup (CI/CD)
```

## üß™ Testing Framework

### Test Execution

**Use**: pytest with comprehensive test suite

```bash
# Install dependencies
pip install -r requirements-test.txt

# Run tests
pytest                          # All tests
pytest -m "unit"               # Fast unit tests only
pytest -m "integration"        # Integration tests
pytest -m "azure"              # Azure-dependent tests
pytest --cov=scripts           # With coverage
pytest -n auto                 # Parallel execution
```

### Test Structure

- **Unit tests**: Fast, isolated function testing
- **Integration tests**: Cross-component testing
- **Azure tests**: Cloud resource testing
- **UI tests**: Interface testing

## üìã VS Code Integration

### Available Tasks

- `dev-start`: Main development startup
- `cleanup-dotnet`: Process cleanup
- `load-env`: Environment loading
- `azure-setup`: Azure configuration
- `azure-test-connection`: Azure connectivity testing
- `test-fast`: Quick unit tests

### Recommended Workflow

1. **Start**: Run "dev-start" task
2. **Develop**: Make changes with `dotnet watch` running
3. **Test**: Run "test-fast" task for quick feedback
4. **Clean**: Run "cleanup-dotnet" when done

## üîß Development Best Practices

### Python Script Usage

- **Always use Python scripts** over PowerShell equivalents
- **Test scripts** before committing changes
- **Use VS Code tasks** for consistent execution
- **Check script output** for proper error handling

### PowerShell Script Standards

- **Use Write-Output** instead of Write-Host for pipeline-compatible output
- **Use Write-Information** for informational messages with -InformationAction parameter
- **Use Write-Verbose** for detailed diagnostic information
- **Avoid Write-Host** for new code - it doesn't write to the pipeline

### Environment Setup

- **Load environment first**: `python scripts/load-env.py`
- **Test connections**: `python scripts/load-env.py --test-connections`
- **Validate Azure setup**: `python scripts/azure-setup.py --test-connection`

### Testing Strategy

- **Run unit tests** before committing
- **Use coverage reports** to identify gaps
- **Test Azure features** with proper mocking
- **Parallel execution** for faster feedback

## üéØ **Technology Stack Reality Check**

### Primary Development Languages

- C#/.NET: Core application (WinUI 3 with Syncfusion WinUI controls)
- Python: Build tooling, testing, automation scripts
- PowerShell: Legacy scripts, Windows-specific operations

### UI Platform: Uno Platform Migration (November 2025)

**CRITICAL DECISION**: Migrating from WPF to **Uno Platform** (not pure WinUI 3)

**Current Status**: In Progress - WPF to Uno Platform Migration
**Target Framework**: .NET 9.0
**UI Framework**: Uno Platform 5.3+ (WinUI 3 API on Windows, cross-platform elsewhere)
**Syncfusion Controls**: Syncfusion WinUI (fully compatible with Uno Platform)
**Prism Support**: Full support since 2020 via Prism.Uno.WinUI package

#### **Why Uno Platform vs Pure WinUI 3**

**Evaluation Results** (November 2025):

- ‚úÖ **Uno Maturity**: Mature platform with 350+ enhancements in v5.3 (2024)
- ‚úÖ **Code Reuse**: 80-90% WPF code reusable via WinUI API surface
- ‚úÖ **Prism Integration**: Battle-tested since 2020, no reported issues
- ‚úÖ **Syncfusion Compatibility**: WinUI controls work with Uno (inline styling, no external themes needed)
- ‚úÖ **Windows Performance**: Runs as native WinUI on Windows desktop (no performance penalty)
- ‚úÖ **Cross-Platform Future**: Enables iOS/Android/WebAssembly without rewrite
- ‚ö†Ô∏è **Minor Trade-offs**: Occasional Uno-specific XAML tweaks for platform differences

**Success Probability**: 85-90% based on 2024/2025 community data and Uno's WPF migration guide

#### **Uno Platform Migration Rules (MANDATORY)**

**1. XAML Namespaces**

```xml
<!-- ‚úÖ CORRECT - Uno/WinUI namespaces -->
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
xmlns:prism="http://prismlibrary.com/"
xmlns:syncfusion="using:Syncfusion.UI.Xaml.Core"

<!-- ‚ùå WRONG - WPF namespaces -->
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" (WPF version)
xmlns:prism="http://www.codeplex.com/prism" (legacy)
```

**2. Application Shell**

```csharp
// ‚úÖ CORRECT - Uno/WinUI App structure
public partial class App : PrismApplication
{
    protected override Window CreateShell()
    {
        return Container.Resolve<MainWindow>(); // MainWindow is Window, not Page
    }

    protected override void OnLaunched(LaunchActivatedEventArgs args)
    {
        base.OnLaunched(args);
        var window = CreateShell();
        window.Activate();
    }
}

// ‚ùå WRONG - WPF pattern
protected override void OnStartup(StartupEventArgs e) // WPF-specific
```

**3. Dependency Injection Setup**

```csharp
// ‚úÖ CORRECT - Uno/WinUI host builder pattern
protected override void RegisterTypes(IContainerRegistry containerRegistry)
{
    // Register services
    containerRegistry.RegisterSingleton<INavigationService, NavigationService>();

    // Register for navigation
    containerRegistry.RegisterForNavigation<DashboardView, DashboardViewModel>();
}

// Configure container via Prism.DryIoc (same as WPF)
protected override IContainerExtension CreateContainerExtension()
{
    return new DryIocContainerExtension();
}
```

**4. Resource Dictionary Loading**

```xml
<!-- ‚úÖ CORRECT - Uno/WinUI ms-appx URIs -->
<ResourceDictionary Source="ms-appx:///Themes/FluentDark.xaml" />

<!-- ‚ùå WRONG - WPF pack URIs -->
<ResourceDictionary Source="pack://application:,,,/Themes/FluentDark.xaml" />
```

**5. Syncfusion Control Usage**

```xml
<!-- ‚úÖ CORRECT - Syncfusion WinUI controls (Uno-compatible) -->
<syncfusion:SfDataGrid ItemsSource="{Binding Items}" />
<syncfusion:DockingManager DockFill="True" />

<!-- ‚ùå WRONG - Syncfusion WPF controls -->
<syncfusion:SfDataGrid ItemsSource="{Binding Items}" /> <!-- WPF version -->
```

**6. Custom Region Adapters**

```csharp
// ‚úÖ CORRECT - Target Uno/WinUI controls
using Microsoft.UI.Xaml.Controls; // WinUI namespace for Uno

public class FrameRegionAdapter : RegionAdapterBase<Frame>
{
    // Adapter targets Microsoft.UI.Xaml.Controls.Frame
}

// ‚ùå WRONG - WPF controls
using System.Windows.Controls; // WPF namespace
```

**7. Prism Package References**

```xml
<!-- ‚úÖ CORRECT - Uno-specific Prism packages -->
<PackageReference Include="Prism.Uno.WinUI" Version="9.0.271" />
<PackageReference Include="Prism.DryIoc.Uno.WinUI" Version="9.0.271" />

<!-- ‚ùå WRONG - WPF Prism packages -->
<PackageReference Include="Prism.Uno.WinUI" Version="9.0.537" />
<PackageReference Include="Prism.DryIoc" Version="9.0.271" /> <!-- WPF version -->
```

#### **Uno Migration Checklist**

**Phase 1: Project Setup**

- [ ] Install Uno Platform templates: `dotnet new install Uno.Templates`
- [ ] Create Uno solution: `dotnet new unoapp -o WileyWidget.Uno`
- [ ] Reference Prism.Uno.WinUI and Prism.DryIoc.Uno.WinUI packages
- [ ] Reference Syncfusion.Core.WinUI (same package as pure WinUI 3)
- [ ] Set TargetFramework to `net9.0` with Windows TFM for desktop

**Phase 2: XAML Migration**

- [ ] Convert WPF namespaces to WinUI namespaces
- [ ] Replace `Window` base with Uno's `Window` (WinUI-compatible)
- [ ] Convert `pack://` URIs to `ms-appx:///` URIs
- [ ] Update Syncfusion control references to WinUI versions
- [ ] Test XAML rendering on Windows desktop (Uno WinUI runtime)

**Phase 3: Code-Behind Migration**

- [ ] Replace `OnStartup` with `OnLaunched` in App.xaml.cs
- [ ] Update shell to return `Window` instead of WPF `Window`
- [ ] Migrate dependency injection to Prism.Uno.WinUI patterns
- [ ] Update custom region adapters to target `Microsoft.UI.Xaml.Controls`
- [ ] Test navigation and region management

**Phase 4: Theme & Styling**

- [ ] Migrate `ThemeUtility` to use `SfSkinManager` for Uno/WinUI
- [ ] Convert WPF resource dictionaries to WinUI format
- [ ] Test FluentDark/FluentLight themes on Windows
- [ ] Validate inline Syncfusion styling (no external theme files needed)

**Phase 5: Testing & Validation**

- [ ] Run CSX tests (30-series, 60P-series) against Uno build
- [ ] Validate Prism container resolution (CSX 20-25 tests)
- [ ] Test DatabaseInitializer with Uno (CSX 49-52 tests)
- [ ] Run xUnit tests for ViewModels/Services
- [ ] Smoke test all major features on Windows desktop

#### **Known Uno-Specific Adjustments**

**1. Window Sizing**

```csharp
// WinUI/Uno uses AppWindow API for sizing
var appWindow = window.AppWindow;
appWindow.Resize(new Windows.Graphics.SizeInt32 { Width = 1280, Height = 720 });
```

**2. Dependency Property Registration**

```csharp
// Same pattern as WinUI 3
public static readonly DependencyProperty MyProperty =
    DependencyProperty.Register("My", typeof(string), typeof(MyControl), null);
```

**3. Async Initialization**

```csharp
// Uno supports async patterns in App lifecycle
protected override async Task OnInitializeAsync(IActivatedEventArgs args)
{
    await InitializeServicesAsync();
}
```

**4. Platform-Specific Code**

```csharp
// Use #if directives for Windows-specific features
#if WINDOWS
    // Windows-only code (desktop APIs)
#endif
```

#### **Documentation References**

- **Uno Platform Docs**: https://platform.uno/docs/
- **Uno WPF Migration Guide**: https://platform.uno/docs/articles/migrating-from-wpf.html
- **Prism.Uno.WinUI**: https://github.com/PrismLibrary/Prism/tree/master/src/Uno
- **Syncfusion WinUI**: https://help.syncfusion.com/winui/overview (same for Uno)
- **Uno + Prism Sample**: https://github.com/PrismLibrary/Prism-Samples-Uno

#### **Risk Mitigation Strategy**

**High Success Indicators**:

- ‚úÖ Prism support since 2020 (4+ years mature)
- ‚úÖ Syncfusion officially supports Uno Platform
- ‚úÖ 350+ Uno enhancements in 2024 alone
- ‚úÖ Native WinUI runtime on Windows (no emulation layer)
- ‚úÖ Active community with 8,500+ GitHub stars

**Contingency Plan**:

- If critical Uno blocker discovered ‚Üí Fall back to pure WinUI 3 (Windows-only)
- Incremental migration: Module-by-module conversion with parallel WPF support
- Use Uno's WPF compatibility layer for gradual transition

**Expected Timeline**:

- Weeks 1-2: Project setup + XAML namespace conversion
- Weeks 3-4: Code-behind migration + Prism integration
- Week 5: Theme/styling migration
- Week 6: Testing + validation
- Week 7-8: Bug fixes + optimization

**Success Criteria**:

- ‚úÖ All CSX tests passing (Prism, Database, Navigation)
- ‚úÖ xUnit test suite at 70%+ coverage
- ‚úÖ Windows desktop app launches and navigates
- ‚úÖ Syncfusion controls render correctly
- ‚úÖ Theme switching functional (FluentDark/FluentLight)
- ‚úÖ No performance regressions vs WPF baseline

### Development Workflow Strategy

1. **New Scripts**: Prefer Python for cross-platform compatibility
2. **Windows-Specific**: Use PowerShell only when Python cannot provide equivalent functionality
3. **Migration Path**: Gradually replace PowerShell scripts with Python equivalents
4. **Testing**: All scripts must have comprehensive test coverage

### When to Use PowerShell vs Python

**Use PowerShell:**

- Windows-specific system operations
- .NET assembly manipulation and inspection
- Existing working scripts (don't break what's working)
- Azure CLI integration (az commands)
- Windows registry operations

**Use Python:**

- Cross-platform file operations
- HTTP requests and API calls
- Complex data processing and analysis
- Build automation and CI/CD pipelines
- New development tooling and utilities

## üèóÔ∏è **Development Environment Architecture**

### Layered Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  VS Code Tasks (User Interface)     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Python Scripts (Primary Tooling)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  PowerShell Scripts (Legacy/Windows)‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  .NET CLI / Azure CLI (Foundations) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Build System Strategy

- **dotnet CLI**: Direct use for compilation and publishing
- **Python orchestration**: High-level build coordination
- **PowerShell**: Windows-specific build steps only
- **Azure CLI**: Cloud operations and deployments

### Testing Strategy Enhancement

**Dual-Phase Testing Strategy (CSX + xUnit)**:

**Phase 1: Exploratory Testing with C# MCP**

- **Tool**: `mcp_csharp-mcp_eval_c_sharp` (AI-driven, inline execution)
- **Use For**:
  - New ViewModel/Service exploration
  - Edge case validation
  - Async pattern testing
  - Pre-xUnit prototyping
- **Benefits**: Zero overhead, instant feedback, iterative refinement
- **Documentation**: See `docs/reference/DIRECT_MCP_TESTING_GUIDE.md`

**Phase 2: Formalized Regression Testing with xUnit**

- **Tool**: xUnit + Moq + FluentAssertions
- **Coverage**: Models, Data, Business, ViewModels
- **Patterns**: Arrange-Act-Assert, Builder Pattern, Mocking, Theory Tests
- **CI/CD**: Integrated into GitHub Actions pipeline

**Testing Workflow**:

1. Prototype with C# MCP for rapid validation
2. Convert passing prototypes to permanent xUnit tests
3. Run xUnit suite in CI/CD for regression prevention
4. Maintain 70%+ code coverage threshold

- **Pester**: PowerShell script testing (maintain existing coverage)
- **pytest**: Python script testing (expand coverage)
- **Integration tests**: Cross-script testing
- **Performance tests**: Profile loading and build times

## üìä Benefits of Python Tooling

- **Cross-platform**: Works on Windows, macOS, Linux
- **Maintainable**: Clean, testable Python code
- **Integrated**: Seamless VS Code integration
- **Testable**: Comprehensive test framework with coverage
- **Secure**: Proper environment variable handling
- **Performant**: Optimized for development workflows

## üîÑ Migration from PowerShell

The Python scripts provide enhanced functionality:

- Additional validation and error handling
- Cross-platform compatibility
- Performance optimizations
- Comprehensive logging and monitoring
- Unit test coverage
- Better integration with modern development tools

## üÜò Troubleshooting

### Common Issues

- **Environment not loading**: Run `python scripts/load-env.py`
- **Azure connection failed**: Run `python scripts/azure-setup.py --test-connection`
- **Processes not cleaning**: Run `python scripts/cleanup-dotnet.py --force`
- **Tests failing**: Check `pytest.ini` configuration

### Getting Help

- Check `scripts/README.md` for detailed documentation
- Run scripts with `--help` flag for usage information
- Check VS Code task output for detailed error messages

## üé® **Theme Management Guidelines**

### SkinManager Implementation - AUTHORITY WITH EXCEPTION

**CRITICAL RULE**: `ThemeUtility` is the **exclusive** theme management system for Wiley Widget for runtime and per-window theme applications. Direct `SfSkinManager` calls are permitted only in App.xaml.cs for global bootstrap before controls load (as recommended by Syncfusion).

#### ‚úÖ **Approved Theme Implementation**

**Use SfSkinManager directly for initial global theme in App; ThemeUtility for all subsequent/dynamic applications.**

#### **Supported Themes**

- `FluentDark` (default)
- `FluentLight`

#### **Global Theme Bootstrap Pattern**

**In App.xaml.cs OnStartup/OnInitialized, use direct SfSkinManager for global initialization:**

```csharp
public partial class App : PrismApplication
{
    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        // ‚úÖ ALLOWED - Direct SfSkinManager for global bootstrap
        SfSkinManager.ApplyThemeAsDefaultStyle = true;
        SfSkinManager.ApplicationTheme = new Theme("FluentLight");
    }
}
```

#### **Theme Application Pattern**

**All Windows must apply themes using ThemeUtility:**

```csharp
public partial class MyWindow : Window
{
    public MyWindow()
    {
        InitializeComponent();

        // ‚úÖ REQUIRED - Apply theme using ThemeUtility
        ThemeUtility.TryApplyTheme(this, SettingsService.Instance.Current.Theme);
    }
}
```

#### **Theme Switching**

**Use ThemeUtility for runtime theme changes:**

```csharp
// ‚úÖ CORRECT - Runtime theme switching
private void OnFluentDarkClick(object sender, RoutedEventArgs e)
{
    ThemeUtility.TryApplyTheme(this, "FluentDark");
    SettingsService.Instance.Current.Theme = "FluentDark";
    SettingsService.Instance.Save();
}
```

#### **Benefits of Centralized Theme Management**

- **Consistency**: All windows use identical theme application logic (except global bootstrap)
- **Error Handling**: Robust fallback to FluentLight on theme failures
- **Normalization**: Automatic theme name canonicalization
- **Logging**: Comprehensive theme application tracking
- **Maintenance**: Single point of change for theme logic
- **Syncfusion Alignment**: Direct SfSkinManager for global init as recommended

#### **Code Review Checklist**

- [ ] Direct `SfSkinManager` calls only in App.xaml.cs for global bootstrap
- [ ] All windows use `ThemeUtility.TryApplyTheme()` in constructors
- [ ] Theme switching uses `ThemeUtility` methods
- [ ] Custom theme objects are not created
- [ ] Theme persistence uses `SettingsService`

#### **Testing Requirements**

- [ ] Theme inheritance tests pass
- [ ] Theme switching functionality verified
- [ ] Fallback behavior tested
- [ ] All windows apply themes consistently

## üìÖ **PowerShell ‚Üí Python Migration Roadmap**

### Phase 1 (Immediate - 2 weeks)

- [ ] Replace Write-Host in all active PowerShell scripts
- [ ] Add PowerShell output standards to guidelines
- [ ] Update VS Code tasks to use Python scripts where possible
- [ ] Audit existing scripts and categorize (keep, migrate, deprecate)

### Phase 2 (Short-term - 1 month)

- [ ] Migrate build.ps1 ‚Üí build.py (if beneficial)
- [ ] Enhance azure-setup.py to replace azure-setup.ps1
- [ ] Create Python equivalents for high-usage PowerShell scripts
- [ ] Update testing framework to cover both Python and PowerShell

### Phase 3 (Medium-term - 3 months)

- [ ] Deprecate all non-essential PowerShell scripts
- [ ] Update documentation to reflect Python-first approach
- [ ] Train development team on Python development practices
- [ ] Establish Python as the primary scripting language for new features

## üìò PRISM_USAGE (MANDATORY)

The following Prism usage guidance is required for all code and Copilot suggestions in the Wiley-Widget project. These rules are mandatory: contributors and AI assistants must follow them. Add this section to any local Copilot instruction file for consistency.

### Overview

Wiley-Widget uses Prism for modularity, MVVM, regions, and navigation. This section is the single source of truth for Prism usage in the repository.

### Prism Version

- Target Prism: 9.x (use `Prism.Core` and `Prism.DryIoc` packages for WinUI 3 compatibility).
- **WinUI 3 Migration**: Prism for WinUI 3 uses same core patterns as WPF but targets `Microsoft.UI.Xaml`
- Any upgrade must be validated by CI and a release plan.

### Mandatory C# Namespaces

Use only the modern Prism namespaces (do not use legacy or CodePlex-era namespaces):

- `Prism.Ioc`
- `Prism.Modularity`
- `Prism.Mvvm`
- `Prism.Regions`
- `Prism.Events`
- `Prism.DryIoc`
- `Prism.Navigation`

If Copilot suggests `Prism.Navigation.Regions`, `Microsoft.Practices.Prism`, or `http://www.codeplex.com/prism` URIs, replace them with the modern equivalents above.

### XAML Namespaces

Use:

- `xmlns:prism="http://prismlibrary.com/"`

Do NOT use legacy Prism XAML URIs.

### Region Adapter Rules (MANDATORY)

- Custom region adapters are allowed only when they map views to the control's intended API (for example, bind `IEnumerable` to `ItemsSource` for data controls). Do not insert UIElements into data hosts.
- Register adapters in `App.ConfigureRegionAdapterMappings` (use `RegionAdapterMappings.RegisterMapping`).
- Adapter implementations must use `Prism.Regions` types (e.g., `IRegionBehaviorFactory`, `RegionAdapterBase<T>`, `IRegion`).
- Adapters must avoid memory leaks: unsubscribe CollectionChanged handlers or use weak subscriptions.

### DockingManager and SfDataGrid Project Rules

- `SfDataGrid` must not be treated as a general-purpose region host for UI views. Approved pattern: adapter binds an `IEnumerable` (or viewmodel collection) to the grid's `ItemsSource`.
- `DockingManagerRegionAdapter` must find the correct host slot by comparing the Prism attached RegionName property on ContentControls:
  - `var name = contentControl.GetValue(Prism.Regions.RegionManager.RegionNameProperty) as string;`
- If adapter behavior is ambiguous, prefer explicit exceptions or clear logging rather than letting Prism throw opaque casting errors.

### Bootstrapping and Syncfusion Licensing (MANDATORY)

- Register Syncfusion licenses in the `App()` constructor before any control instances are created.
- Apply themes only via the project's `ThemeUtility` (do not call `SfSkinManager.SetTheme` directly in application code).

### Code Review Checklist (Prism)

- [ ] Modern Prism namespaces only
- [ ] XAML uses `http://prismlibrary.com/` prism URI
- [ ] Custom region adapters in `WileyWidget.Regions` inherit `RegionAdapterBase<T>`
- [ ] Adapters map to control APIs (ItemsSource/document API) ‚Äî no UIElement insertion into data hosts
- [ ] CollectionChanged handlers are unsubscribed or weak
- [ ] Syncfusion license registered in App() constructor
- [ ] Theme application uses ThemeUtility only

### Local Copilot Instructions

Copy and paste the mandatory section above into your local `copilot-instructions.md` (VS Code user prompt) if you maintain it, so Copilot suggestions in-editor follow these rules.
