using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Xunit;
using WileyWidget.WinForms.Controls;
using WileyWidget.WinForms.ViewModels;

namespace WileyWidget.IntegrationTests;

/// <summary>
/// Integration tests for Panel+ViewModel resolution chain.
/// Ensures panels correctly resolve ViewModels with scoped dependencies from scoped service providers.
/// </summary>
public class PanelViewModelResolutionTests : IDisposable
{
    private readonly ServiceProvider _serviceProvider;
    private readonly IServiceScope _scope;

    public PanelViewModelResolutionTests()
    {
        // Build service provider with in-memory database for testing
        var services = new ServiceCollection();

        // Register logging
        services.AddLogging(builder => builder.AddDebug());

        // Register DbContext with in-memory database
        var dbName = $"panel-tests-{Guid.NewGuid():N}";
        services.AddDbContext<WileyWidget.Data.AppDbContext>(options =>
            options.UseInMemoryDatabase(dbName));

        // Register DbContextFactory (if needed by some services)
        services.AddDbContextFactory<WileyWidget.Data.AppDbContext>(options =>
            options.UseInMemoryDatabase(dbName), ServiceLifetime.Scoped);

        // Register memory cache (required by repositories)
        services.AddMemoryCache();

        // Register repositories (scoped)
        services.AddScoped<WileyWidget.Business.Interfaces.IAccountsRepository,
            WileyWidget.Data.AccountsRepository>();
        services.AddScoped<WileyWidget.Business.Interfaces.IBudgetRepository,
            WileyWidget.Data.BudgetRepository>();
        services.AddScoped<WileyWidget.Business.Interfaces.IMunicipalAccountRepository,
            WileyWidget.Data.MunicipalAccountRepository>();

        // Register ViewModels (transient)
        services.AddTransient<AccountsViewModel>();
        services.AddTransient<DashboardViewModel>();
        services.AddTransient<ChartViewModel>();
        services.AddTransient<WileyWidget.ViewModels.BudgetOverviewViewModel>();
        services.AddTransient<SettingsViewModel>();

        // Register other dependencies ViewModels might need
        services.AddSingleton<Microsoft.Extensions.Configuration.IConfiguration>(
            new Microsoft.Extensions.Configuration.ConfigurationBuilder().Build());
        services.AddTransient<WileyWidget.Services.Abstractions.IDashboardService,
            WileyWidget.Services.DashboardService>();

        // Build provider with validation enabled
        _serviceProvider = services.BuildServiceProvider(new ServiceProviderOptions
        {
            ValidateScopes = true,  // Critical: ensures we catch scope violations
            ValidateOnBuild = true
        });

        // Create a test scope
        _scope = _serviceProvider.CreateScope();
    }

    [STAFact]
    public void AccountsViewModel_CanResolveFromScope_WithRepositoryDependencies()
    {
        // Arrange & Act
        var viewModel = _scope.ServiceProvider.GetRequiredService<AccountsViewModel>();

        // Assert
        Assert.NotNull(viewModel);
    }

    [STAFact]
    public void DashboardViewModel_CanResolveFromScope_WithRepositoryDependencies()
    {
        // Arrange & Act
        var viewModel = _scope.ServiceProvider.GetRequiredService<DashboardViewModel>();

        // Assert
        Assert.NotNull(viewModel);
    }

    [STAFact]
    public void ChartViewModel_CanResolveFromScope()
    {
        // Arrange & Act
        var viewModel = _scope.ServiceProvider.GetRequiredService<ChartViewModel>();

        // Assert
        Assert.NotNull(viewModel);
    }

    [STAFact]
    public void BudgetOverviewViewModel_CanResolveFromScope()
    {
        // Arrange & Act
        var viewModel = _scope.ServiceProvider.GetRequiredService<WileyWidget.ViewModels.BudgetOverviewViewModel>();

        // Assert
        Assert.NotNull(viewModel);
    }

    [STAFact]
    public void SettingsViewModel_CanResolveFromScope()
    {
        // Arrange & Act
        var viewModel = _scope.ServiceProvider.GetRequiredService<SettingsViewModel>();

        // Assert
        Assert.NotNull(viewModel);
    }

    [STAFact]
    public void ResolvingViewModelFromRootProvider_ThrowsException_WhenHasScopedDependencies()
    {
        // This test verifies that the DI container correctly enforces scope validation
        // when a transient ViewModel has scoped dependencies (like repositories)

        // Arrange & Act & Assert
        // This SHOULD throw because AccountsViewModel depends on IAccountsRepository (scoped)
        // and we're resolving it from the root provider without creating a scope first
        var exception = Assert.Throws<InvalidOperationException>(() =>
        {
            var viewModel = _serviceProvider.GetRequiredService<AccountsViewModel>();
        });

        // Verify it's a scope validation error
        Assert.Contains("scope", exception.Message, StringComparison.OrdinalIgnoreCase);
    }

    [STAFact]
    public void Repository_IsScoped_NotSingleton()
    {
        // Arrange: Create two separate scopes
        using var scope1 = _serviceProvider.CreateScope();
        using var scope2 = _serviceProvider.CreateScope();

        // Act: Resolve repository from each scope
        var repo1 = scope1.ServiceProvider.GetRequiredService<WileyWidget.Business.Interfaces.IAccountsRepository>();
        var repo2 = scope2.ServiceProvider.GetRequiredService<WileyWidget.Business.Interfaces.IAccountsRepository>();

        // Assert: Different instances (scoped, not singleton)
        Assert.NotSame(repo1, repo2);
    }

    [STAFact]
    public void ViewModel_ResolvedMultipleTimes_FromSameScope_ReturnsDifferentInstances()
    {
        // ViewModels are registered as Transient, so each resolution should return a new instance

        // Arrange & Act
        var viewModel1 = _scope.ServiceProvider.GetRequiredService<AccountsViewModel>();
        var viewModel2 = _scope.ServiceProvider.GetRequiredService<AccountsViewModel>();

        // Assert: Different instances (transient)
        Assert.NotSame(viewModel1, viewModel2);
    }

    [STAFact]
    public void DbContext_IsScoped_NotSingleton()
    {
        // Arrange: Create two separate scopes
        using var scope1 = _serviceProvider.CreateScope();
        using var scope2 = _serviceProvider.CreateScope();

        // Act: Resolve DbContext from each scope
        var context1 = scope1.ServiceProvider.GetRequiredService<WileyWidget.Data.AppDbContext>();
        var context2 = scope2.ServiceProvider.GetRequiredService<WileyWidget.Data.AppDbContext>();

        // Assert: Different instances (scoped, not singleton)
        Assert.NotSame(context1, context2);
    }

    [STAFact]
    public void Repository_ResolvedMultipleTimes_FromSameScope_ReturnsSameInstance()
    {
        // Repositories are registered as Scoped, so multiple resolutions from the same scope
        // should return the same instance

        // Arrange & Act
        var repo1 = _scope.ServiceProvider.GetRequiredService<WileyWidget.Business.Interfaces.IAccountsRepository>();
        var repo2 = _scope.ServiceProvider.GetRequiredService<WileyWidget.Business.Interfaces.IAccountsRepository>();

        // Assert: Same instance (scoped)
        Assert.Same(repo1, repo2);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            _scope?.Dispose();
            _serviceProvider?.Dispose();
        }
    }
}
