name: Grok Code Review

on:
  pull_request:
    branches: [main, develop]
    paths:
      - src/**/*.cs
      - tests/**/*.cs
      - .github/workflows/**

permissions:
  contents: read
  pull-requests: write

jobs:
  grok-review:
    name: Grok-powered PR Review
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for proper diff

      - name: Get PR diff
        id: diff
        run: |
          # Get the base commit and current commit
          BASE_SHA=${{ github.event.pull_request.base.sha }}
          HEAD_SHA=${{ github.event.pull_request.head.sha }}

          # Generate unified diff
          DIFF=$(git diff $BASE_SHA..$HEAD_SHA -- \
            'src/**/*.cs' 'tests/**/*.cs' \
            --unified=3 \
            --diff-filter=ACMTU 2>/dev/null | head -20000)

          # Store diff in a temp file (handles large diffs)
          echo "$DIFF" > /tmp/pr.diff

          # Count lines changed
          LINES_CHANGED=$(echo "$DIFF" | grep -c '^[+-]' || echo 0)
          echo "lines_changed=$LINES_CHANGED" >> $GITHUB_OUTPUT
          echo "diff_size=$(wc -c < /tmp/pr.diff)" >> $GITHUB_OUTPUT

      - name: Skip if no significant changes
        if: steps.diff.outputs.lines_changed < 10
        run: echo "No significant C# changes detected; skipping Grok review"

      - name: Prepare review prompt
        id: prompt
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          PR_AUTHOR="${{ github.event.pull_request.user.login }}"

          # Read diff from file
          DIFF=$(cat /tmp/pr.diff)

          # Truncate diff if too large
          if [ ${#DIFF} -gt 15000 ]; then
            DIFF=$(echo "$DIFF" | head -300)
            DIFF="$DIFF... (diff truncated due to size)"
          fi

# Write the static portion of the prompt via printf lines (avoids heredoc indentation issues)
          printf "You are a senior code reviewer for a Syncfusion WinForms/C# project.\n\n" > /tmp/review_prompt.txt
          printf "STRICT RULES TO ENFORCE:\n" >> /tmp/review_prompt.txt
          printf "1. SfSkinManager Theming - SfSkinManager is the SINGLE SOURCE OF TRUTH for theming\n" >> /tmp/review_prompt.txt
          printf "  - Allowed: SfSkinManager.SetVisualStyle() calls\n" >> /tmp/review_prompt.txt
          printf "  - Allowed: SfSkinManager.LoadAssembly() for theme initialization\n" >> /tmp/review_prompt.txt
          printf "  - Allowed: Semantic status colors (Color.Red, Color.Green, Color.Orange)\n" >> /tmp/review_prompt.txt
          printf "  - FORBIDDEN: Manual BackColor/ForeColor assignments (except form-level docking setup)\n" >> /tmp/review_prompt.txt
          printf "  - FORBIDDEN: Custom color properties/dictionaries\n" >> /tmp/review_prompt.txt
          printf "  - FORBIDDEN: Competing theme managers\n\n" >> /tmp/review_prompt.txt
          printf "2. C# Best Practices:\n" >> /tmp/review_prompt.txt
          printf "  - No .Result or .Wait() on Task (must be async/await)\n" >> /tmp/review_prompt.txt
          printf "  - Async/await patterns for I/O operations\n" >> /tmp/review_prompt.txt
          printf "  - Modern C# idioms (var, records, required members where appropriate)\n" >> /tmp/review_prompt.txt
          printf "  - Remove unused imports and variables\n" >> /tmp/review_prompt.txt
          printf "  - XML doc comments for public members\n\n" >> /tmp/review_prompt.txt
          printf "3. Test Coverage: Check if new code has corresponding tests\n\n" >> /tmp/review_prompt.txt
          printf "4. Performance: Highlight potential memory leaks, N+1 queries, or blocking calls\n\n" >> /tmp/review_prompt.txt
          printf "REVIEW FORMAT:\n- Start with a brief summary (1-2 sentences)\n- List 3-5 KEY findings (use ### for headers)\n- For each finding: describe issue, show code snippet, suggest fix\n- End with: Recommendation (Approve/Request Changes/Comment)\n" >> /tmp/review_prompt.txt

          # Append dynamic values safely
          printf "\nPR TITLE: %s\nPR AUTHOR: %s\n\nPR DESCRIPTION:\n%s\n\nCHANGED CODE (unified diff):\n%s\n" "$PR_TITLE" "$PR_AUTHOR" "$PR_BODY" "$DIFF" >> /tmp/review_prompt.txt

          echo "prompt_file=/tmp/review_prompt.txt" >> $GITHUB_OUTPUT

      - name: Call Grok API for review
        if: ${{ secrets.XAI_API_KEY != '' }}
        id: grok
        env:
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
          GROK_MODEL: grok-4-0709  # or try "grok-4-fast-reasoning" for speed
          GROK_TEMPERATURE: '0.5'
          GROK_MAX_TOKENS: '2048'
        run: |
          # Read prompt
          PROMPT=$(cat /tmp/review_prompt.txt)

          # Create JSON payload by reading the prompt file (avoid shell-escaping issues). Use env overrides for model/temperature/max_tokens.
          python3 - <<'PY'
          import json, os
          prompt = open('/tmp/review_prompt.txt', 'r', encoding='utf-8').read()
          model = os.environ.get('GROK_MODEL', 'grok-4-0709')
          temperature = float(os.environ.get('GROK_TEMPERATURE', '0.5'))
          max_tokens = int(os.environ.get('GROK_MAX_TOKENS', '2048'))
          payload = {
            "model": model,
            "messages": [
              {"role": "system", "content": "You are an expert code reviewer for a Syncfusion WinForms/C# project. Provide thorough, actionable feedback."},
              {"role": "user", "content": prompt}
            ],
            "temperature": temperature,
            "max_tokens": max_tokens
          }
          with open('/tmp/grok_request.json', 'w', encoding='utf-8') as f:
            json.dump(payload, f)
          PY

          # Call Grok API and capture HTTP status
          RESPONSE_WITH_STATUS=$(curl -s -w "\n%{http_code}" -X POST https://api.x.ai/v1/chat/completions \
            -H "Authorization: Bearer $XAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @/tmp/grok_request.json)
          HTTP_STATUS=$(echo "$RESPONSE_WITH_STATUS" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE_WITH_STATUS" | sed '$d')

          # Expose the raw response for debugging (echo raw response and HTTP status)
          RESPONSE="$RESPONSE_WITH_STATUS"
          echo "API raw response:"
          echo "$RESPONSE"
          echo "HTTP_STATUS: $HTTP_STATUS"
          echo "RESPONSE_BODY:"
          echo "$RESPONSE_BODY"
          echo "$RESPONSE_BODY" > /tmp/grok_review_raw.txt || true
          echo "grok_review_raw=/tmp/grok_review_raw.txt" >> $GITHUB_OUTPUT

          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "grok_error=true" >> $GITHUB_OUTPUT
            echo "grok_error_msg=HTTP $HTTP_STATUS" >> $GITHUB_OUTPUT
            echo "$RESPONSE_BODY" > /tmp/grok_review.txt || true
            echo "grok_review_file=/tmp/grok_review.txt" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Extract response text
          REVIEW=$(echo "$RESPONSE_BODY" | python3 -c 'import json,sys; r=json.load(sys.stdin); print(r.get("choices",[{}])[0].get("message",{}).get("content","Error: No response from Grok"))')

          # Save review to file (handles multiline output)
          echo "$REVIEW" > /tmp/grok_review.txt

          # Check for API errors in the body (even if HTTP 200)
          if echo "$RESPONSE_BODY" | grep -q '"error"'; then
            ERROR=$(echo "$RESPONSE_BODY" | python3 -c 'import json,sys; r=json.load(sys.stdin); print(r.get("error",{}).get("message","Unknown error"))')
            echo "grok_error=true" >> $GITHUB_OUTPUT
            echo "grok_error_msg=$ERROR" >> $GITHUB_OUTPUT
            echo "$RESPONSE_BODY" > /tmp/grok_review.txt || true
            echo "grok_review_file=/tmp/grok_review.txt" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "grok_review_file=/tmp/grok_review.txt" >> $GITHUB_OUTPUT

      - name: Skip Grok review if API key missing
        if: ${{ secrets.XAI_API_KEY == '' }}
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '‚ö†Ô∏è **Grok review skipped**: `XAI_API_KEY` secret not set in repository. To enable Grok PR reviews, create the `XAI_API_KEY` secret in the repo settings.'
            });

      - name: Post review as PR comment
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const review = fs.readFileSync('/tmp/grok_review.txt', 'utf8');
            const commentHeader = '## ü§ñ Grok Code Review\n\n';
            const commentFooter = '\n\n---\n*This review was generated by Grok (xAI).*';
            const comment = commentHeader + review + commentFooter;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Handle review errors
        if: failure() && steps.grok.outputs.grok_error == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const errMsg = '${{ steps.grok.outputs.grok_error_msg }}';
            const body = '‚ö†Ô∏è **Grok Review Failed**: ' + errMsg + '\n\nPlease ensure XAI_API_KEY is configured and Grok API is accessible.';
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
