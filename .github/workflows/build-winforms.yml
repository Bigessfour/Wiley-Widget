name: CI/CD Dashboard Enhanced (95% Success Target)

on:
  push:
    branches: [main, develop, feature/dashboard-production-ready]
  pull_request:
    branches: [main, develop]
  workflow_dispatch: {}

permissions:
  contents: read
  checks: write
  pull-requests: write

jobs:
  workflow-lint:
    name: Lint workflows & YAML
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run super-linter for workflows (YAML + GitHub Actions)
        uses: github/super-linter@v4
        env:
          VALIDATE_WORKFLOW: true
          VALIDATE_YAML: true
          # Reduce scope so linter focuses on workflow files and YAML
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  ps-script-analyze:
    name: PowerShell scripts - static analysis
    runs-on: windows-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install PSScriptAnalyzer
        shell: pwsh
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser -MinimumVersion 1.22.0

      - name: Analyze PowerShell scripts under ./scripts
        shell: pwsh
        run: |
          $errors = $false
          Get-ChildItem -Path ./scripts -Recurse -Filter "*.ps1" -File | ForEach-Object {
            Write-Host "Analyzing: $($_.FullName)"
            $results = Invoke-ScriptAnalyzer -Path $_.FullName -Severity Error -Recurse -EnableExit
            if ($results) { $results | Format-Table -AutoSize; $errors = $true }
          }
          if ($errors) { Write-Error "Script analysis found issues"; exit 1 }

  build:
    # Bound the runtime to avoid runaway runs and add concurrency to prevent duplicate builds
    runs-on: windows-latest
    timeout-minutes: 60
    concurrency:
      group: build-winforms-${{ github.ref }}
      cancel-in-progress: true

    env:
      COVERAGE_THRESHOLD: 85
      COVERAGE_FAIL_ON_MISSING: "false" # Set 'true' to make missing coverage a hard failure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.nuget/packages
            ~/.local/share/NuGet
          key: nuget-packages-${{ runner.os }}-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            nuget-packages-${{ runner.os }}-

      - name: Cache dotnet tools
        uses: actions/cache@v4
        with:
          path: ${{ env.USERPROFILE }}\.dotnet\tools
          key: dotnet-tools-${{ runner.os }}-${{ hashFiles('**/Directory.Packages.props') }}
          restore-keys: dotnet-tools-${{ runner.os }}-

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Clear NuGet caches (best-effort)
        run: |
          # Clearing caches sometimes fails if disk locked — ignore failures
          try {
            dotnet nuget locals all --clear
          } catch {
            Write-Host 'clear caches failed - continuing'
          }

      - name: Restore NuGet packages (retry)
        shell: powershell
        run: |
          $maxAttempts = 3
          $attempt = 0
          do {
            $attempt++
            Write-Host "dotnet restore attempt $attempt"
            dotnet restore WileyWidget.sln --verbosity minimal -clp:PerformanceSummary
            if ($LASTEXITCODE -eq 0) { break }
            Start-Sleep -Seconds (5 * $attempt)
          } while ($attempt -lt $maxAttempts)
          if ($LASTEXITCODE -ne 0) {
            Write-Error "dotnet restore failed after $attempt attempts"
            exit 1
          }

      - name: Build WinForms Application
        shell: pwsh
        run: dotnet build WileyWidget.sln --configuration Release --no-restore --verbosity minimal

      - name: Test - Unit Tests (with coverage)
        shell: powershell
        run: |
          $maxAttempts=2
          for ($i=1; $i -le $maxAttempts; $i++) {
            try {
              dotnet test tests/WileyWidget.Services.UnitTests/WileyWidget.Services.UnitTests.csproj --configuration Release --collect:"XPlat Code Coverage" --logger trx --results-directory ./TestResults/UnitTests
              exit 0
            } catch {
              Write-Warning "Unit tests attempt $i failed: $_"
              if ($i -eq $maxAttempts) { exit 1 }
              Start-Sleep -Seconds (10 * $i)
            }
          }

      - name: Test - Dashboard Service Tests (filtered)
        shell: powershell
        run: |
          $maxAttempts=2
          for ($i=1; $i -le $maxAttempts; $i++) {
            try {
              dotnet test tests/WileyWidget.Services.Tests/WileyWidget.Services.Tests.csproj --filter "FullyQualifiedName~Dashboard" --configuration Release --logger trx --collect:"XPlat Code Coverage" --results-directory ./TestResults/Dashboard
              break
            } catch {
              Write-Warning "Dashboard tests attempt $i failed: $_"
              if ($i -eq $maxAttempts) { exit 1 }
              Start-Sleep -Seconds (10 * $i)
            }
          }

      - name: Test - Integration Tests (with coverage)
        shell: powershell
        run: |
          # Guard: integration tests require QuickBooks/3rd-party secrets. If the necessary secrets are not present, skip gracefully in PRs/forks.
          if (-not $env:QBO_CLIENT_ID -or -not $env:QBO_CLIENT_SECRET) {
            Write-Warning "Skipping integration tests: required secrets (QBO_CLIENT_ID/QBO_CLIENT_SECRET) not present in environment. Set repository secrets or run from main for integration checks."
            exit 0
          }

          $maxAttempts=2
          for ($i=1; $i -le $maxAttempts; $i++) {
            try {
              dotnet test tests/WileyWidget.Services.Tests/WileyWidget.Services.Tests.csproj --configuration Release --collect:"XPlat Code Coverage" --logger trx --results-directory ./TestResults/Integration
              break
            } catch {
              Write-Warning "Integration tests attempt $i failed: $_"
              if ($i -eq $maxAttempts) { exit 1 }
              Start-Sleep -Seconds (10 * $i)
            }
          }

      # Disabled: TRUNK_PATH not configured
      # - name: Ensure .trunk exists and create setup-ci symlink (non-Windows)
      #   if: runner.os != 'Windows'
      #   shell: bash
      #   run: |
      #     set -euo pipefail
      #     mkdir -p .trunk
      #     if [ -z "${TRUNK_PATH:-}" ]; then
      #       echo "ERROR: TRUNK_PATH is not set. Cannot create symlink"
      #       exit 1
      #     fi
      #     SRC="$TRUNK_PATH/setup-ci"
      #     DEST=".trunk/setup-ci"
      #     if [ ! -e "$SRC" ]; then
      #       echo "ERROR: expected trunk source does not exist: $SRC"
      #       ls -la "$TRUNK_PATH" || true
      #       exit 1
      #     fi
      #     ln -sfn "$SRC" "$DEST"
      #     echo "Created symlink: $DEST -> $SRC"

      # Disabled: TRUNK_PATH not configured
      # - name: Ensure .trunk exists and create setup-ci symlink (Windows)
      #   if: runner.os == 'Windows'
      #   shell: pwsh
      #   run: |
      #     $ErrorActionPreference = 'Stop'
      #     New-Item -ItemType Directory -Path .trunk -Force | Out-Null
      #     if (-not $env:TRUNK_PATH) {
      #       Write-Error 'ERROR: TRUNK_PATH is not set. Cannot create symlink'
      #       exit 1
      #     }
      #     $src = Join-Path $env:TRUNK_PATH 'setup-ci'
      #     $dest = Join-Path (Get-Location) '.trunk\setup-ci'
      #     if (-not (Test-Path $src)) {
      #       Write-Error "ERROR: expected trunk source does not exist: $src"
      #       Get-ChildItem -Path $env:TRUNK_PATH -Force | Write-Output
      #       exit 1
      #     }
      #     if (Test-Path $dest) { Remove-Item -Path $dest -Force -Recurse }
      #     try {
      #       New-Item -ItemType SymbolicLink -Path $dest -Target $src | Out-Null
      #       Write-Host "Created symlink: $dest -> $src"
      #     } catch {
      #       Write-Warning "Could not create symlink (permission or unsupported). Falling back to copying files: $_"
      #       Copy-Item -Path $src -Destination $dest -Recurse -Force
      #       Write-Host "Copied $src to $dest"
      #     }

      # Disabled: Requires TRUNK_PATH setup-ci which is not configured
      # - name: Trunk validation (CI)
      #   uses: trunk-io/trunk-action@v1
      #   with:
      #     arguments: --ci --upload

      - name: Collect coverage summary
        if: always()
        shell: powershell
        run: |
          # Install reportgenerator in a non-interactive way and ensure it's available in PATH
          dotnet tool install -g dotnet-reportgenerator-globaltool --version 5.1.23
          if ($LASTEXITCODE -ne 0) { Write-Host 'reportgenerator already installed' }
          $toolsPath = "$env:USERPROFILE\.dotnet\tools"
          $env:PATH = "$toolsPath;$env:PATH"

          Write-Host 'Searching for coverage files under ./TestResults'
          $coverageFiles = Get-ChildItem -Path ./TestResults -Recurse -Filter "coverage.cobertura.xml" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName

          if (!$coverageFiles) {
            Write-Warning "No coverage files found. COVERAGE_FAIL_ON_MISSING=$env:COVERAGE_FAIL_ON_MISSING"
            if ($env:COVERAGE_FAIL_ON_MISSING -eq 'true') { exit 1 } else { Write-Host 'Skipping coverage-failure, continuing' ; exit 0 }
          }

          reportgenerator -reports:$($coverageFiles -join ";") -targetdir:coverage-report -reporttypes:TextSummary -verbosity:Error

          $summary = Get-Content (Join-Path -Path 'coverage-report' -ChildPath 'Summary.txt') -ErrorAction Stop
          Write-Host $summary

          $match = ($summary | Select-String -Pattern "Line: (\d+\.?\d*)%" -AllMatches)
          if (-not $match.Matches.Count) {
            Write-Warning 'Could not extract line coverage from the Summary.txt'
            if ($env:COVERAGE_FAIL_ON_MISSING -eq 'true') { exit 1 } else { exit 0 }
          }

          $line = $match.Matches[0].Groups[1].Value
          if (-not [double]::TryParse($line, [ref]$parsed)) {
            Write-Warning 'Failed to parse coverage percentage'
            exit 0
          }

          $coverage = [double]$parsed
          Write-Host "Total line coverage: $coverage%"
          if ($coverage -lt $env:COVERAGE_THRESHOLD) {
            Write-Warning "Coverage $coverage% is below threshold of $env:COVERAGE_THRESHOLD% (NOTE: this is a warning in CI)
            Consider increasing tests or adjust threshold if intentional."
            # Optionally: fail the job by changing this to exit 1
          }

      - name: Restore WinForms project (retry)
        shell: pwsh
        run: |
          $maxAttempts = 3
          $attempt = 0
          do {
            $attempt++
            Write-Host "dotnet restore attempt $attempt (WinForms)"
            dotnet restore src/WileyWidget.WinForms/WileyWidget.WinForms.csproj --verbosity minimal -clp:PerformanceSummary
            if ($LASTEXITCODE -eq 0) { break }
            Start-Sleep -Seconds (5 * $attempt)
          } while ($attempt -lt $maxAttempts)
          if ($LASTEXITCODE -ne 0) {
            Write-Error "dotnet restore WileyWidget.WinForms failed after $attempt attempts"
            exit 1
          }

      - name: Build WinForms Project
        shell: pwsh
        run: dotnet build src/WileyWidget.WinForms/WileyWidget.WinForms.csproj --configuration Release --no-restore --verbosity minimal

      - name: Publish Application
        shell: pwsh
        run: dotnet publish src/WileyWidget.WinForms/WileyWidget.WinForms.csproj --configuration Release --output ./publish --no-restore

      - name: Verify startup smoke test (best-effort)
        continue-on-error: true
        run: powershell -NoProfile -ExecutionPolicy Bypass -File .\scripts\verify-startup.ps1 -ExePath ./publish/WileyWidget.WinForms.exe -TimeoutSeconds 20

      - name: Validate Dashboard Deployment Package
        shell: pwsh
        run: |
          if (!(Test-Path "./publish/WileyWidget.WinForms.exe")) {
            Write-Error "Dashboard executable not found in publish directory"
            exit 1
          }
          $size = (Get-Item "./publish/WileyWidget.WinForms.exe").Length / 1MB
          Write-Host "Dashboard executable size: $([math]::Round($size, 2)) MB"
          if ($size -gt 100) {
            Write-Warning "Dashboard executable exceeds 100MB - consider optimization"
          }

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: wiley-widget-winforms
          path: ./publish/
          retention-days: 30

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ./TestResults/
          retention-days: 7

  ui-e2e:
    # Manual-only: UI E2E tests are interactive and should be executed on demand
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: [self-hosted, windows]
    needs: build
    timeout-minutes: 120

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Confirm runner suitability
        shell: powershell
        run: |
          # Ensure the runner is self-hosted and interactive — otherwise abort with a clear message
          if (-not ($env:RUNNER_LABELS -match 'self-hosted')) {
            Write-Error 'UI E2E tests require a self-hosted Windows runner with UI access. Re-run with an appropriate runner.'
            exit 1
          }

      - name: Build application
        run: dotnet build WileyWidget.sln --configuration Release --no-restore

      - name: Run WinForms UI E2E (interactive)
        run: dotnet test tests/WileyWidget.WinForms.E2ETests/WileyWidget.WinForms.E2ETests.csproj --configuration Release
        # Leave out --no-build for safety: ensure tests are built for this runner
