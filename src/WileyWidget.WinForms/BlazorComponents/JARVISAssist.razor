@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using WileyWidget.Models
@using WileyWidget.Services.Abstractions
@using static WileyWidget.Models.ChatMessage
@using Syncfusion.Blazor
@using Syncfusion.Blazor.Inputs
@using Syncfusion.Blazor.Buttons
@using CommunityToolkit.Mvvm.Input
@implements IDisposable
@inject IChatBridgeService ChatBridge
@inject IJSRuntime JS

<div class="jarvis-container">
    <div class="messages" @ref="_messageContainer" role="log" aria-live="polite" aria-label="Chat messages">
        @foreach (var msg in _messages)
        {
            <div class="message @(msg.IsUser ? "user" : "assistant")">
                <div class="message-content">
                    @msg.Content
                </div>
            </div>
        }
        @if (_isThinking)
        {
            <div class="message assistant thinking" role="alert" aria-live="assertive">
                <div class="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        }
    </div>

    <div class="input-area">
        <SfTextArea @bind-Value="_userInput"
                    Placeholder="Ask JARVIS anything..."
                    Rows="3"
                    aria-label="Message input"
                    @onkeyup="HandleKeyUp"></SfTextArea>
        @if (!string.IsNullOrEmpty(_errorMessage))
        {
            <div class="error-message">@_errorMessage</div>
        }
        <SfButton Command="_sendCommand" Disabled="@(string.IsNullOrWhiteSpace(_userInput) || _isThinking || _isSending)">Send</SfButton>
    </div>
</div>

<style>
    .jarvis-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        background: var(--sf-background);
        color: var(--sf-text);
        font-family: 'Segoe UI', sans-serif;
    }

    .messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
    }

    .message {
        margin-bottom: 15px;
        max-width: 80%;
        padding: 12px;
        border-radius: 8px;
        line-height: 1.5;
    }

    .message.user {
        align-self: flex-end;
        background: var(--sf-primary);
        color: var(--sf-text);
        margin-left: auto;
    }

    .message.assistant {
        align-self: flex-start;
        background: var(--sf-surface);
        border: 1px solid var(--sf-border);
    }

    .message.thinking {
        background: transparent;
        border: none;
    }

    .typing-indicator span {
        display: inline-block;
        width: 8px;
        height: 8px;
        background: var(--sf-primary);
        border-radius: 50%;
        margin-right: 5px;
        animation: blink 1.4s infinite both;
    }

    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @@keyframes blink {
        0%, 80%, 100% { opacity: 0; }
        40% { opacity: 1; }
    }

    .input-area {
        padding: 20px;
        background: var(--sf-surface);
        display: flex;
        gap: 10px;
    }

    /* SfTextArea styling */
    .input-area .e-textarea,
    .input-area .e-input-group {
        flex: 1;
        background: var(--sf-input-background);
        border: 1px solid var(--sf-border);
        color: var(--sf-text);
        border-radius: 4px;
    }

    .error-message {
        color: var(--sf-error);
        font-size: 0.9em;
        margin-top: 5px;
    }
</style>

@code {
    private string _userInput = "";
    private bool _isThinking = false;
    private bool _isSending = false;
    private List<ChatMessage> _messages = new();
    private ElementReference _messageContainer;
    private string _conversationId = Guid.NewGuid().ToString();
    private string _errorMessage = "";
    private CancellationTokenSource? _cts;
    private AsyncRelayCommand? _sendCommand;
    private DateTime _lastRenderTime = DateTime.UtcNow;
    private const int MinRenderIntervalMs = 100; // Throttle renders to max 10/sec
    private bool _suppressRender;
    private Task? _deferredRenderTask;
    private string? _streamingMessageId;

    [Parameter] public string Theme { get; set; } = "office-2019-colorful";

    protected override void OnInitialized()
    {
        _sendCommand = new AsyncRelayCommand(SendMessageAsync);
        _messages.Add(new ChatMessage { Content = "Hello, I am JARVIS. How can I assist you today?", IsUser = false });

        ChatBridge.OnMessageReceived += HandleMessageReceived;
        ChatBridge.ResponseChunkReceived += HandleResponseChunkReceived;
        ChatBridge.ExternalPromptRequested += HandleExternalPromptRequested;
    }

    private void HandleMessageReceived(object? sender, ChatMessage msg)
    {
        _ = InvokeAsync(() =>
        {
            if (msg == null)
            {
                return;
            }

            var messageId = string.IsNullOrWhiteSpace(msg.Id) ? Guid.NewGuid().ToString() : msg.Id;
            var existing = _messages.FirstOrDefault(m => m.Id == messageId);
            if (existing == null)
            {
                msg.Id = messageId;
                _messages.Add(msg);
            }
            else
            {
                existing.Content = msg.Content;
                existing.IsUser = msg.IsUser;
                existing.Timestamp = msg.Timestamp;
            }

            _streamingMessageId = messageId;
            _isThinking = false;
            RequestRender();
        });
    }

    private void HandleResponseChunkReceived(object? sender, ChatResponseChunkEventArgs e)
    {
        if (string.IsNullOrEmpty(e.Chunk))
        {
            return;
        }

        _ = InvokeAsync(() =>
        {
            var message = _streamingMessageId != null
                ? _messages.FirstOrDefault(m => m.Id == _streamingMessageId)
                : null;

            if (message == null)
            {
                message = new ChatMessage
                {
                    Id = Guid.NewGuid().ToString(),
                    IsUser = false,
                    Content = string.Empty
                };
                _messages.Add(message);
                _streamingMessageId = message.Id;
            }

            message.Content += e.Chunk;
            _isThinking = false;
            RequestRender();
        });
    }

    private void HandleExternalPromptRequested(object? sender, ChatExternalPromptEventArgs e)
    {
        if (string.IsNullOrWhiteSpace(e.Prompt))
        {
            return;
        }

        _ = InvokeAsync(async () =>
        {
            if (_isSending)
            {
                return;
            }

            _userInput = e.Prompt;
            await SendMessageAsync();
        });
    }

    private void RequestRender()
    {
        var now = DateTime.UtcNow;
        var timeSinceLastRender = (now - _lastRenderTime).TotalMilliseconds;
        if (timeSinceLastRender >= MinRenderIntervalMs)
        {
            _lastRenderTime = now;
            _suppressRender = false;
            StateHasChanged();
            ScrollToBottom();
            return;
        }

        var delay = (int)Math.Max(1d, MinRenderIntervalMs - timeSinceLastRender);
        _suppressRender = true;

        if (_deferredRenderTask == null || _deferredRenderTask.IsCompleted)
        {
            _deferredRenderTask = InvokeAsync(async () =>
            {
                try
                {
                    await Task.Delay(delay);
                    _lastRenderTime = DateTime.UtcNow;
                    _suppressRender = false;
                    StateHasChanged();
                    ScrollToBottom();
                }
                catch
                {
                    _suppressRender = false;
                }
            });
        }
    }

    protected override bool ShouldRender()
    {
        if (_suppressRender)
        {
            _suppressRender = false;
            return false;
        }

        return true;
    }

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(_userInput) || _isThinking || _isSending)
            return;

        // Validation
        if (_userInput.Length > 2000)
        {
            _errorMessage = "Message is too long. Maximum 2000 characters.";
            StateHasChanged();
            return;
        }

        // Sanitize input
        var sanitizedInput = _userInput.Trim();
        if (string.IsNullOrEmpty(sanitizedInput))
            return;

        // Rate limiting
        _isSending = true;
        _errorMessage = "";

        var userMsg = new ChatMessage { Content = sanitizedInput, IsUser = true, Id = Guid.NewGuid().ToString() };
        _messages.Add(userMsg);
        var prompt = sanitizedInput;
        _userInput = "";
        _isThinking = true;
        _streamingMessageId = null;

        // Single state change for all mutations
        _lastRenderTime = DateTime.UtcNow;
        StateHasChanged();
        ScrollToBottom();

        // Cancellation token for long calls
        _cts = new CancellationTokenSource();
        _cts.CancelAfter(TimeSpan.FromMinutes(5)); // Timeout after 5 minutes

        try
        {
            await ChatBridge.SubmitPromptAsync(prompt, _conversationId);
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error sending message: {ex.Message}";
            _isThinking = false;
            _lastRenderTime = DateTime.UtcNow;
            StateHasChanged();
        }
        finally
        {
            _isSending = false;
            _cts?.Dispose();
            _cts = null;
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessageAsync();
        }
    }

    private void ScrollToBottom()
    {
        JS.InvokeVoidAsync("scrollToBottom", _messageContainer);
    }

    public void Dispose()
    {
        ChatBridge.OnMessageReceived -= HandleMessageReceived;
        ChatBridge.ResponseChunkReceived -= HandleResponseChunkReceived;
        ChatBridge.ExternalPromptRequested -= HandleExternalPromptRequested;

        _cts?.Cancel();
        _cts?.Dispose();
    }
}
