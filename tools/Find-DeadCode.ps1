<#
.SYNOPSIS
    Finds potentially unused methods in C# files
.DESCRIPTION
    Searches for private methods that appear to never be called
.PARAMETER ProjectPath
    Root path to scan (default: src/WileyWidget.WinForms)
.PARAMETER IncludePublic
    Include public methods in the scan (default: false)
.PARAMETER ExcludeAutoGenerated
    Exclude designer and generated files (default: true)
#>

param(
    [string]$ProjectPath = "src/WileyWidget.WinForms",
    [switch]$IncludePublic = $false,
    [switch]$ExcludeAutoGenerated = $true
)

Write-Host "`nğŸ” Dead Code Scanner v1.0" -ForegroundColor Cyan
Write-Host "Scanning: $ProjectPath`n" -ForegroundColor Gray

# Ensure output directory exists
$outputDir = "tmp"
if (-not (Test-Path $outputDir)) {
    New-Item -ItemType Directory -Path $outputDir | Out-Null
}

# Build exclusion filter
$exclusionPatterns = @()
if ($ExcludeAutoGenerated) {
    $exclusionPatterns += "*.Designer.cs"
    $exclusionPatterns += "*.g.cs"
    $exclusionPatterns += "*AssemblyInfo.cs"
}

# Find all C# files
$allFiles = Get-ChildItem -Path $ProjectPath -Filter "*.cs" -Recurse |
    Where-Object {
        $file = $_
        $include = $true
        foreach ($pattern in $exclusionPatterns) {
            if ($file.Name -like $pattern) {
                $include = $false
                break
            }
        }
        $include
    }

Write-Host "ğŸ“„ Found $($allFiles.Count) C# files to analyze" -ForegroundColor Green

# Regex patterns
$privateMethodPattern = 'private\s+(static\s+)?(async\s+)?(void|Task|Task<[^>]+>|\w+)\s+(\w+)\s*\('
$publicMethodPattern = 'public\s+(static\s+)?(async\s+)?(void|Task|Task<[^>]+>|\w+)\s+(\w+)\s*\('

# Find all methods
Write-Host "`nğŸ” Scanning for method declarations..." -ForegroundColor Yellow
$methods = @()

foreach ($file in $allFiles) {
    $content = Get-Content -Path $file.FullName -Raw

    # Find private methods
    $privateMatches = [regex]::Matches($content, $privateMethodPattern)
    foreach ($match in $privateMatches) {
        $methodName = $match.Groups[4].Value
        $lineNumber = ($content.Substring(0, $match.Index) -split "`n").Count

        # Skip common patterns that are likely used
        if ($methodName -match '^(Dispose|InitializeComponent|On\w+|Handle\w+|_\w+_\w+)$') {
            continue
        }

        $methods += [PSCustomObject]@{
            MethodName = $methodName
            Visibility = 'private'
            File = $file.FullName
            RelativePath = $file.FullName.Replace("$PWD\", "")
            LineNumber = $lineNumber
            Declaration = $match.Value
        }
    }

    # Find public methods if requested
    if ($IncludePublic) {
        $publicMatches = [regex]::Matches($content, $publicMethodPattern)
        foreach ($match in $publicMatches) {
            $methodName = $match.Groups[4].Value
            $lineNumber = ($content.Substring(0, $match.Index) -split "`n").Count

            if ($methodName -match '^(Main|Dispose|ToString|GetHashCode|Equals)$') {
                continue
            }

            $methods += [PSCustomObject]@{
                MethodName = $methodName
                Visibility = 'public'
                File = $file.FullName
                RelativePath = $file.FullName.Replace("$PWD\", "")
                LineNumber = $lineNumber
                Declaration = $match.Value
            }
        }
    }
}

Write-Host "âœ… Found $($methods.Count) method declarations to check" -ForegroundColor Green

# Check each method for references
Write-Host "`nğŸ” Checking for method usage..." -ForegroundColor Yellow
$unusedMethods = @()
$usedMethods = @()
$progressCount = 0

foreach ($method in $methods) {
    $progressCount++
    Write-Progress -Activity "Checking method usage" -Status "$progressCount of $($methods.Count)" -PercentComplete (($progressCount / $methods.Count) * 100)

    # Search for method invocations across all files
    # Use word boundary to avoid partial matches
    $searchPattern = "\b$($method.MethodName)\s*\("

    $references = $allFiles | Select-String -Pattern $searchPattern | Where-Object {
        # Exclude the declaration line itself
        -not ($_.Path -eq $method.File -and $_.LineNumber -eq $method.LineNumber)
    }

    $referenceCount = $references.Count

    if ($referenceCount -eq 0) {
        $unusedMethods += $method | Add-Member -NotePropertyName "ReferenceCount" -NotePropertyValue 0 -PassThru
    } else {
        $usedMethods += $method | Add-Member -NotePropertyName "ReferenceCount" -NotePropertyValue $referenceCount -PassThru
    }
}

Write-Progress -Activity "Checking method usage" -Completed

# Generate report
Write-Host "`nğŸ“Š Dead Code Analysis Results" -ForegroundColor Cyan
Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Gray

Write-Host "`nğŸ“ˆ Summary:" -ForegroundColor Yellow
Write-Host "  Total Methods Scanned: $($methods.Count)" -ForegroundColor White
Write-Host "  Potentially Unused:    $($unusedMethods.Count)" -ForegroundColor Red
Write-Host "  In Use:                $($usedMethods.Count)" -ForegroundColor Green
Write-Host "  Unused Percentage:     $(if ($methods.Count -gt 0) { [math]::Round(($unusedMethods.Count / $methods.Count) * 100, 2) } else { 0 })%" -ForegroundColor $(if ($unusedMethods.Count -gt 0) { 'Red' } else { 'Green' })

if ($unusedMethods.Count -gt 0) {
    Write-Host "`nâš ï¸  Potentially Unused Methods:" -ForegroundColor Red
    Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor Gray

    # Group by file for better readability
    $unusedMethods | Group-Object -Property RelativePath | ForEach-Object {
        Write-Host "`nğŸ“„ $($_.Name)" -ForegroundColor Cyan
        $_.Group | ForEach-Object {
            Write-Host "   Line $($_.LineNumber): $($_.Visibility) $($_.MethodName)()" -ForegroundColor Yellow
        }
    }
}

# Export detailed report
$reportPath = "$outputDir/dead-code-report.csv"
$unusedMethods | Select-Object MethodName, Visibility, RelativePath, LineNumber, Declaration, ReferenceCount |
    Export-Csv -Path $reportPath -NoTypeInformation

Write-Host "`nğŸ’¾ Detailed Report Saved" -ForegroundColor Green
Write-Host "   Location: $reportPath" -ForegroundColor Gray

# Export JSON for programmatic consumption
$jsonReportPath = "$outputDir/dead-code-report.json"
$report = @{
    ScanDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    ProjectPath = $ProjectPath
    TotalMethods = $methods.Count
    UnusedCount = $unusedMethods.Count
    UsedCount = $usedMethods.Count
    UnusedMethods = $unusedMethods
}
$report | ConvertTo-Json -Depth 5 | Out-File -FilePath $jsonReportPath -Encoding UTF8

Write-Host "   JSON Report: $jsonReportPath" -ForegroundColor Gray

# Highlight high-risk candidates
$highRiskMethods = $unusedMethods | Where-Object { $_.MethodName.Length -gt 10 -and $_.Visibility -eq 'private' }
if ($highRiskMethods.Count -gt 0) {
    Write-Host "`nğŸ¯ High-Risk Candidates (Long Names, Private):" -ForegroundColor Magenta
    $highRiskMethods | Select-Object -First 10 | ForEach-Object {
        Write-Host "   $($_.RelativePath):$($_.LineNumber) - $($_.MethodName)" -ForegroundColor White
    }
}

Write-Host "`nâœ… Scan Complete!" -ForegroundColor Green
Write-Host "`nNext Steps:" -ForegroundColor Cyan
Write-Host "  1. Review the report: $reportPath" -ForegroundColor Gray
Write-Host "  2. Manually verify each method (may be used via reflection/events)" -ForegroundColor Gray
Write-Host "  3. Remove or mark with [Obsolete] if truly unused" -ForegroundColor Gray
Write-Host "  4. Re-run scan after cleanup to track progress`n" -ForegroundColor Gray
